# 10. درخت ریشه‌دار

## خواسته سوال

درختی ریشه‌دار با `n` رأس و وزن‌های اولیه روی هر رأس داده شده است. سپس `q` عملیات به صورت `(v, w)` داریم که وزن رأس `v` را به `w` تغییر می‌دهند. بعد از هر به‌روزرسانی، باید مجموع وزن بیشینه‌ی یک مجموعه‌ی مستقل روی کل درخت را گزارش کنیم.

**ورودی‌:**

عدد صحیح `n`

`n-1` یال غیر‌جهت‌دار که درخت را می‌سازند

`n` عدد وزن اولیه‌ی هر رأس

عدد صحیح `q`

`q` خط هر کدام دو عدد `(v, w)`



**خروجی:**

بعد از هر عملیات، بیشینه‌ی وزن مجموعه‌ی مستقل روی درخت  

## راه حل

### تعریف dp

دو آرایه $dp0$ و $dp1$ را برای هر راس $v$ به شکل زیر تعریف می کنیم:

$$dp0[v] = \sum_{u \in \mathrm{children}(v)} \max\bigl(dp0[u],dp1[u]\bigr)$$

$$dp1[v] = val[v] + \sum_{u \in \mathrm{children}(v)} dp0[u]$$

### مقداردهی اولیه

با یک DFS از ریشه (مثلاً رأس $1$):

والد و فرزندان هر رأس را تعیین می‌کنیم.

در حالت پس‌گرد (post-order)، مقادیر `dp0` و `dp1` را محاسبه می‌کنیم.

### به‌روزرسانی وزن و پاسخ‌گویی

پس از هر بار که `val[v]` تغییر کرد:
از رأس `v` تا ریشه بالا می‌رویم.  

برای هر رأس $x$ در مسیر، مجدداً مقادیر dp ها را آپدیت می کنیم.

$$dp1[x] = val[x] + \sum_{u \in \mathrm{children}(x)} dp0[u]$$

$$dp0[x] = \sum_{u \in \mathrm{children}(x)} \max(dp0[u],dp1[u])$$

در پایان پاسخ مسئله اینگونه به دست می آید.

$$\max\bigl(dp0[1],dp1[1]\bigr)$$

## پیچیدگی زمان و حافظه

**پیچیدگی زمان:**

$$O(n + q \cdot n)$$

**پیچیدگی حافظه:**

$$O(n)$$
