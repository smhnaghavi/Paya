# 7. مسیر درخت

## خواسته سوال

پیدا کردن طولانی ترین مسیر، به ازای هر راس $v$ درون یک درخت ریشه دار و وزن دار، به طوری که مسیر از راس $v$ آغاز شود و مجموع وزن های یال های مسیر مضرب P باشد.

**ورودی‌:**
- یک عدد صحیح `n` (تعداد رئوس درخت)
- یک عدد صحیح `P` (عددی اول)
- `n-1` خط که هرکدام سه عدد `u v w` را مشخص می‌کنند (یال بین `u` و `v` با وزن `w`)

**خروجی:**
- برای هر رأس `v`، بیشینه طول مسیر از `v` که مجموع وزن‌های آن مضربی از `P` باشد.

## راه حل

### تعریف DP پایین‌رو و بالا‌رو

$dpD_{v, i}$:

   بیشترین تعداد یال‌هایی که در مسیری از `v` به پایین طی می‌شود و مجموع وزن یال‌ها در این مسیر باقیمانده `i` بر `P` دارد.  

  این مقدار در اولین DFS (`DFS1`) و در زمان خروج از هر رأس با بررسی زیر‌درخت‌های آن آپدیت می‌شود.  

$dpU_{v, i}$:

  بیشترین تعداد یال‌هایی که در مسیری از `v` به بالا (از طریق پدرش) طی می‌شود و مجموع وزن یال‌ها باقیمانده `i` بر `P` دارد.  

  این مقدار در DFS دوم (`DFS2`) و در زمان ورود به هر رأس و بررسی اثر مسیرهای دیگر فرزندان آپدیت می‌شود.

### الگوریتم DFS

#### DFS اول – پایین‌رو (`DFS1`)
برای هر رأس `v`:

ابتدا DFS را روی همه‌ی فرزندان اجرا می‌کنیم.

سپس به ازای هر فرزند `u` و وزن `w`، برای هر مقدار `i`:
  
  اگر `dpD[u][i]` معتبر باشد، مقدار `dpD[v][(i + w) % P]` را با `dpD[u][i] + 1` آپدیت می‌کنیم.

#### DFS دوم – بالا‌رو (`DFS2`)
برای هر رأس `v`:

به ازای هر مقدار `i` از 0 تا `P-1`، از میان مسیرهای `dpD` بچه‌ها و `dpU` خود `v`، بهترین دو مسیر مستقل (با رئوس متفاوت) را نگه می‌داریم.

سپس به ازای هر فرزند `u`، از میان مسیرهای دیگر (غیر از `u`) مقدار `dpU[u][(i + w) % P]` را تعیین می‌کنیم. اگر مسیر معتبری باشد، یک واحد به آن اضافه می‌شود.

در انتها DFS را روی `u` ادامه می‌دهیم.

### استخراج خروجی
پس از اجرای هر دو DFS، برای هر رأس `v`:

خروجی نهایی `max(dpD[v][0], dpU[v][0])` خواهد بود.


### راه دوم اگر مقدار P زیاد باشد
در این راه به ازای هر راس $v$ الگوریتم DFS را از این راس اجرا میکنیم و مسیر های که شروعشان این راس است را چک میکنیم و اگر مسیری بر P بخش پذیر بود طول این مسیر را در `ans[v]` آپدیت میکنیم

## پیچیدگی زمان و حافظه

**پیچیدگی زمان:**

$$O(P \cdot n)$$

چون در هر DFS، برای هر رأس `v`، روی `P` حالت مختلف باقی‌مانده کار می‌کنیم.  
اگر `P > n` باشد، بهتر است برای هر رأس DFS مجزایی اجرا کنیم و پاسخ را بیابیم، که در این حالت پیچیدگی زمانی تبدیل می‌شود به:

$$O(n^2)$$

**پیچیدگی حافظه:**

$$O(P \cdot n)$$
