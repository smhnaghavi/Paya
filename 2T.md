
# الگوریتم کوله‌پشتی

در این سوال، نسخه‌ای از الگوریتم کوله‌پشتی را بررسی می‌کنیم چرا که گراف در ابتدا جنگل است و با کم کردن یالها رد اخر نیز جنگل می‌ماند پس محدودیتی گراف در سوال ایجاد نمی‌کند

---

## ایده اصلی

در الگوریتم کوله‌پشتی ۰/۱ کلاسیک، ما برای هر آیتم و هر بودجه ممکن، مقدار بهینه را نگهداری می‌کنیم. اما واقعیت این است که برای محاسبه `dp[i][j]` تنها به `dp[i-1][j - cost[i]]` نیاز داریم.

---

## چرا از عقب به جلو پیمایش می‌کنیم؟

اگر به صورت افزایشی از 0 به B برویم، ممکن است مقادیر `dp[j]` که در همین iteration به‌روز شده‌اند، دوباره برای `dp[j + cost[i]]` استفاده شوند. این باعث می‌شود که یال بیش از یک‌بار انتخاب شود، که خلاف منطق کوله‌پشتی ۰/۱ است. برای جلوگیری از این مشکل، باید از `B` به `cost[i]` به عقب برویم.

---

## پیچیدگی زمانی و فضایی

- **زمان**:  O(n*B)
- **فضا**: O(B)

---

## نتیجه‌گیری

با استفاده از برنامه‌نویسی پویا این سوال را حل کردیم
